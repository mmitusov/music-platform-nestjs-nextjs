Nest, Mongo 

nodemon: npm install --save-dev nodemon -> "dev": "nodemon -- src/main.ts"

Max, M1kSJEdAfkTE6scP

# Описание NestJS
nest new . - for generating project localy

Чтобы почитстить проэк и начать с нуля удалим все файлы из папки src. Также я не буду писать тесты, поэтому папку test также удалим.

Для начала, в папке src создаем файл main.ts - это будет нашей входной точкой приложения. И создадим там базовую/стартовую конфигурацию нашего сервера, которая включает в себя app.module.ts. Это будет базовой конфигурацией нашего сервера. Под капотом main.ts работает как express приложение. И как в express, мы создаем приложение и задаем ему порт.

app.module.ts который мы передаем в NestFactory.create() при создании приложения - это отдельная инкапсулированая логика которая включает в себя контроллеры и сервисы. И наше приложение может состоять из многих таких модулей, какждый из которых будет овечать за какую-то логику. При чем модули могут содержать внутри себя и другие модули, давая нам возможность создавать комплексную логику. И по своей сути приложение NestJS как раз таки и опрерирует на подобной модульной структуре. Хорошоей практикой считается когда каждый отдельный модуль отвечает за какую-то отдельную логику.

Каждый модуль имеет декоратор @Module(), который, словно обычная функция, примнимает в себя параметром объект. Далее под капотом происходит магия и нам возвращается новый класс, созданный по переданным в контроллер параметрам.

Также стоит заметить, что во время компиляции будут обрабатываться только те модули которые мы используем, включая всю вложеную в них логику (контроллеры и провайдеры(сервисы)). А те модули, что нигде не используются - ресурсы на их компяляцию во время сборки тратиться не будут.

P.S. Причем стоит заметить, то app.module.ts является точкой входа (ключевым модулем). Поэтому если мы создаем другие/новые модули под какие-то задачи, мы должны убедиться что они указаны и ипрортированы в наш ключевой модуль, от которого уже будет разростатся логика приложения. 

Далее разберемся с певыми контроллерам и провайдерами(сервисами) нашего Nest приложения. Создадим app.controller.ts и app.service.ts.

Внутри controller.ts мы используем декоратор @Controller(), ниже которого мы создаем класс к которому этот декоратор будет применен. Параметром в @Controller передаем маршрут, по которому будут отрабатывать запросы которые мы опишем в классе. Например - '/api'. И теперь этот контроллер будет отрабатывать только по маршруту '/api'. Если мы ничего в него не передаем, то он будет обрабатываться по корневому пути - '/'. А уже внутри @Controller, мы также можем воспользоваться такими декораторами как @Get, @Post и т.д.

Но @Get, @Post и т.д. не так просты. Они так же как и @Controller, принимают внутри себя параметром маршрут по которому они будут отрабатывать. Например, если у нас есть @Controller(/api), а внутри него @Get(/test), то наш контроллер теперь будет иметь GET метод, который будет отрабатывать только по маршруту '/api/test'. P.S. Пустой @Get = корневой путь - '/'.
Если внутри контроллера мы использыуем одинаковый метод запроса, с одинаковым путем, то NestJS отработает только самый первый на очереди метод. А второй метод-дубликат просто проигнорирует.

Так же в NestJS мы больше не используем "res, req" лексику. С "res, req" - NestJS разбирается автоматически под капотом, при помощи @Body(работает с json) @Param(работает с query) декоратора.

Такая логика заменяет систему роутинга, которую мы зачастую используем в　приложениях написаных на express.

Далее поговорил о провайдерах (сервисах). Они хранят в себе сервис логику и работают только в рамках того модуля куда их добавили. Чтобы использовать их внутри модуля, их нужно сперва туда импортировать. После чего мы можем использовать их где угодно в рамках текущего модуля. Но как их передать например в контроллер который находиться в том же модуле? Для этого мы воспользуемся Dependancy Injection. И просто будем передавать в конструктор контроллера те сервисы, которые мы хотим в нем использовать. Но если мы попытаемся использовать сервис который предварительно не был указан в модуле, то этот сервис работать не будет. P.S. Один сервис может использоваться в разных контроллерах
 
Пример импорта сервиса в модуль:
```
@Module ({
    imports: [], //Для случая если мы хотим импорт другие модули. Если ничего не импорт - можем не указывать 
    controllers: [AppController],
    providers: [AppServicel], 
})
```

Самый главный декоратор который используется внутри сервиса - это @Injectable(). Он как раз таки и помогает нам инжектировать созданный нами класс сервиса в другие части текущего модуля.

# Описание разработки проекта
Основной функционал платформы будет включать в себя музыкальные альбомы, треки и коментарии пользователей. Логика креков и коментов бедет объеденена, так как выносить функционал коментов в отдельную логику нет смысла. Под альбомы сделаем БД но какую-то логику писать не будем (остается как ДЗ).

Для начала, в папке src создаем файл main.ts - это будет нашей входной точкой приложения. И создадим там базовую/стартовую конфигурацию нашего сервера, которая включает в себя app.module.ts. Это будет базовой конфигурацией нашего сервера. Под капотом main.ts работает как express приложение. И как в express, мы создаем приложение и задаем ему порт.

Создадим папки под рабочею логику приложения. В src создаем папки под два следующих модуля: album, track. А внутри уже модули, контроллеры и сервисы.

Дале установим подключение c БД. Использовать будем Монго, поэтому устанавливаем mongoose (описание установки в документации Nest.js). На сайте Mongo создаем кластер. Подключаем его в app.module.ts, путем добавления в импорты (чтобы могли использовать БД во всех дочерних модулях). Модели таблиц БД мы будем хранить в папках под каждую отдельную фитчу. Например: src/track/schemas.

Установим и настроим пакет, чтобы мы могли пользоваться .env файлом: npm i --save @nestjs/config.

Чтобы именть возможность пользоваться созданими БД моделями - импортируем их, но уже в родительский модуль самой фитчи track.module.ts. А далее при помощи Dependency Injection (@InjectModel()), будем передавать их в те сервисы, где мы будем их использовать (процесс описан в документации Nest.js). В нашем случае это будет - track.service.ts.

Когда мы хотим создать или обновить данные в БД, то мы должны передать отвечающему за это сервису, не только модель таблицы, с которой он будет работать, но и данные которые он будет в ней создавать обновлять. Для получения данных в конкретный метод сервиса, зачастую используют Data Transfer Object (Dto). Вкратце, Dto - это просто класс, который описывает те поля, которые мы ожидаем на входе в конкретную функцию.

Внутри папки "track", создаем отдельную папку "Dto", где будет указано, какие типы данных "track.service.ts" методы будут в себя принимать.

Далее применяем созданный "Dto" класс, к нужному нам методу. Пусть, например, это будет метод "create" в "track.service.ts". Выглядеть это будет следующим образом:
"async create(createTrackDto: CreateTrackDto): Promise<Track>"
"createTrackDto: CreateTrackDto" - имяПеременной: КлассКоторыйИспользуем
"Promise<Track>" - так как метод create асинхронный, то мы возвращаем промис созданой нами таблицы

Но откуда мы берем данные для "Dto"? А берем мы их из тела запроса, который нам приходит в "track.controller.ts" на @Post() запрос: create(@Body() createTrackDto: CreateTrackDto).
Если мы работаем с query, то используем: "@Get(':id_name') -> @Param('id_name') id_var: typings". id_var - это переменная которая будет хранить в себе пришедший id_name.

Таки образом прописываем все главные сервисы и контроллеры.

Отдельно хотел бы обратить внимание на такой сервис как `const getOneTrack = await this.trackModel.findById(id).populate('comments');`, а особе на применяемы в нем метод - `.populate('comments');`. Дело в том что БД таблица для каждого трека содержит в себе поле 'comments'. Это поле содержит в себе IDшники коментариев к треку, а также оно привязано к БД таблице которая хранит в себе эти самые коментарии - 'Comment'. Тем самым при желании, мы можем возвращать отдельный трек либо просто с указанимы IDшниками в поле 'comments'. Либо при помощи `.populate('comments');`, мы можем наполнить наше поле 'comments' полноценными коментариями которые находяться и всталяются туда через указанные IDшники. А все благодаря тому, что мы связали БД таблицы 'Tracks' и 'Comment'.

На данном этапе мы научились создавать базовую информацию об треках и коментах. Теперь реализуем подгрузку аудио и картинок для альбома. С базовой информацией можно ознакомиться в официальной Nest документации - вкладка File Upload. В Nest работа с файлами идет с помощью библиотеки 'multer'. В нашем случае мы будем загружать сразу несколько файлов, поэтому для этого нужно будет воспользоваться (all with different field name keys) - `FileFieldsInterceptor()`. Воспользуемся им в нашем контроллере.

После того как мы получили файлы в контроллере и передалих их в сервис, нам нужно где-то сохранить эти файлы. Логику по сохранению файлов и работе с ними, мы не будем засовывать в сервис "track", так как как код нужно деструктуризировать, а не разную логику пытаться запихнуть в один сервис. Поэтому, вместо этого создадим отдельный модуль для работы с файлами - src/file/file.module.ts.