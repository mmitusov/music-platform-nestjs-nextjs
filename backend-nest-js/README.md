Nest, Mongo 

nest new . - for generating project localy

Чтобы почитстить проэк и начать с нуля удалим все файлы из папки src. Также я не буду писать тесты, поэтому папку test также удалим.

Для начала, в папке src создаем файл main.ts - это будет нашей входной точкой приложения. И создадим там базовую/стартовую конфигурацию нашего сервера, которая включает в себя app.module.ts. Это будет базовой конфигурацией нашего сервера. Под капотом main.ts работает как express приложение. И как в express, мы создаем приложение и задаем ему порт.

app.module.ts который мы передаем в NestFactory.create() при создании приложения - это отдельная инкапсулированая логика которая включает в себя контроллеры и сервисы. И наше приложение может состоять из многих таких модулей, какждый из которых будет овечать за какую-то логику. При чем модули могут содержать внутри себя и другие модули, давая нам возможность создавать комплексную логику. И по своей сути приложение NestJS как раз таки и опрерирует на подобной модульной структуре. Хорошоей практикой считается когда каждый отдельный модуль отвечает за какую-то отдельную логику.

Каждый модуль имеет декоратор @Module(), который, словно обычная функция, примнимает в себя параметром объект. Далее под капотом происходит магия и нам возвращается новый класс, созданный по переданным в контроллер параметрам.

Также стоит заметить, что во время компиляции будут обрабатываться только те модули которые мы используем, включая всю вложеную в них логику (контроллеры и провайдеры(сервисы)). А те модули, что нигде не используются, ресурсы на их компяляцию во время сборки тратиться не будут.

Далее разберемся с певыми контроллерам и провайдерами(сервисами) нашего Nest приложения. Создадим app.controller.ts и app.service.ts.

Внутри controller.ts мы используем декоратор @Controller(). Параметром в @Controller передаем маршрут, по которому будут отрабатывать запросы которые мы опишем в классе. Например - '/api'. И теперь этот контроллер будет отрабатывать только по маршруту '/api'. Если мы ничего в него не передаем, то он будет обрабатываться по корневому пути - '/'. А уже внутри @Controller, мы также можем воспользоваться такими декораторами как @Get, @Post и т.д.

Но @Get, @Post и т.д. не так просты. Они так же как и @Controller, принимают внутри себя параметром маршрут по которому они будут отрабатывать. Например, если у нас есть @Controller(/api), а внутри него @Get(/test), то наш контроллер теперь будет иметь GET метод, который будет отрабатывать только по маршруту '/api/test'. Пустой @Get = корневой путь - '/'.

Такая логика заменяет систему роутинга, которую мы зачастую используем в　приложениях написаных на express.