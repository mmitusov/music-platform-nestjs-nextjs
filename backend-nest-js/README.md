Nest, Mongo 
public - методы класса доступы как внутри класса так и вне его
privat - методы класса доступы только внутри класса
npm install --save-dev nodemon -> "dev": "nodemon -- src/main.ts"

nest new . - for generating project localy

Чтобы почитстить проэк и начать с нуля удалим все файлы из папки src. Также я не буду писать тесты, поэтому папку test также удалим.

Для начала, в папке src создаем файл main.ts - это будет нашей входной точкой приложения. И создадим там базовую/стартовую конфигурацию нашего сервера, которая включает в себя app.module.ts. Это будет базовой конфигурацией нашего сервера. Под капотом main.ts работает как express приложение. И как в express, мы создаем приложение и задаем ему порт.

app.module.ts который мы передаем в NestFactory.create() при создании приложения - это отдельная инкапсулированая логика которая включает в себя контроллеры и сервисы. И наше приложение может состоять из многих таких модулей, какждый из которых будет овечать за какую-то логику. При чем модули могут содержать внутри себя и другие модули, давая нам возможность создавать комплексную логику. И по своей сути приложение NestJS как раз таки и опрерирует на подобной модульной структуре. Хорошоей практикой считается когда каждый отдельный модуль отвечает за какую-то отдельную логику.

Каждый модуль имеет декоратор @Module(), который, словно обычная функция, примнимает в себя параметром объект. Далее под капотом происходит магия и нам возвращается новый класс, созданный по переданным в контроллер параметрам.

Также стоит заметить, что во время компиляции будут обрабатываться только те модули которые мы используем, включая всю вложеную в них логику (контроллеры и провайдеры(сервисы)). А те модули, что нигде не используются - ресурсы на их компяляцию во время сборки тратиться не будут.

P.S. Причем стоит заметить, то app.module.ts является точкой входа (ключевым модулем). Поэтому если мы создаем другие/новые модули под какие-то задачи, мы должны убедиться что они указаны и ипрортированы в наш ключевой модуль, от которого уже будет разростатся логика приложения. 

Далее разберемся с певыми контроллерам и провайдерами(сервисами) нашего Nest приложения. Создадим app.controller.ts и app.service.ts.

Внутри controller.ts мы используем декоратор @Controller(), ниже которого мы создаем класс к которому этот декоратор будет применен. Параметром в @Controller передаем маршрут, по которому будут отрабатывать запросы которые мы опишем в классе. Например - '/api'. И теперь этот контроллер будет отрабатывать только по маршруту '/api'. Если мы ничего в него не передаем, то он будет обрабатываться по корневому пути - '/'. А уже внутри @Controller, мы также можем воспользоваться такими декораторами как @Get, @Post и т.д.

Но @Get, @Post и т.д. не так просты. Они так же как и @Controller, принимают внутри себя параметром маршрут по которому они будут отрабатывать. Например, если у нас есть @Controller(/api), а внутри него @Get(/test), то наш контроллер теперь будет иметь GET метод, который будет отрабатывать только по маршруту '/api/test'. P.S. Пустой @Get = корневой путь - '/'.
Если внутри контроллера мы использыуем одинаковый метод запроса, с одинаковым путем, то NestJS отработает только самый первый на очереди метод. А второй метод-дубликат просто проигнорирует.

Так же в NestJS мы больше не используем "res, req" лексику. С "res, req" - NestJS разбирается автоматически под капотом, при помощи @Body() декоратора.

Такая логика заменяет систему роутинга, которую мы зачастую используем в　приложениях написаных на express.

Далее поговорил о провайдерах (сервисах). Они хранят в себе сервис логику и работают только в рамках того модуля куда их добавили. Чтобы использовать их внутри модуля, их нужно сперва туда импортировать. После чего мы можем использовать их где угодно в рамках текущего модуля. Но как их передать например в контроллер который находиться в том же модуле? Для этого мы воспользуемся Dependancy Injection. И просто будем передавать в конструктор контроллера те сервисы, которые мы хотим в нем использовать. Но если мы попытаемся использовать сервис который предварительно не был указан в модуле, то этот сервис работать не будет. P.S. Один сервис может использоваться в разных контроллерах
 
Пример импорта сервиса в модуль:
```
@Module ({
    imports: [], //Для случая если мы хотим импорт другие модули. Если ничего не импорт - можем не указывать 
    controllers: [AppController],
    providers: [AppServicel], 
})
```

Самый главный декоратор который используется внутри сервиса - это @Injectable(). Он как раз таки и помогает нам инжектировать созданный нами класс сервиса в другие части текущего модуля.