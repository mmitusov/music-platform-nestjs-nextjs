Nest 
npm i @nestjs/mongoose mongoose
npm i uuid
npm i nodemon
nodemon: npm install --save-dev nodemon -> "dev": "nodemon -- src/main.ts"

# Описание NestJS
***Принцип работы NestJS***
nest new . - for generating project localy

Чтобы почитстить проэк и начать с нуля удалим все файлы из папки src. Также я не буду писать тесты, поэтому папку test также удалим.

Для начала, в папке src создаем файл main.ts - это будет нашей входной точкой приложения. И создадим там базовую/стартовую конфигурацию нашего сервера, которая включает в себя app.module.ts. Это будет базовой конфигурацией нашего сервера. Под капотом main.ts работает как express приложение. И как в express, мы создаем приложение и задаем ему порт.

app.module.ts который мы передаем в NestFactory.create() при создании приложения - это отдельная инкапсулированая логика которая включает в себя контроллеры и сервисы. И наше приложение может состоять из многих таких модулей, какждый из которых будет овечать за какую-то логику. При чем модули могут содержать внутри себя и другие модули, давая нам возможность создавать комплексную логику. И по своей сути приложение NestJS как раз таки и опрерирует на подобной модульной структуре. Хорошоей практикой считается когда каждый отдельный модуль отвечает за какую-то отдельную логику.

Каждый модуль имеет декоратор @Module(), который, словно обычная функция, примнимает в себя параметром объект. Далее под капотом происходит магия и нам возвращается новый класс, созданный по переданным в контроллер параметрам.

Также стоит заметить, что во время компиляции будут обрабатываться только те модули которые мы используем, включая всю вложеную в них логику (контроллеры и провайдеры(сервисы)). А те модули, что нигде не используются - ресурсы на их компяляцию во время сборки тратиться не будут.

P.S. Причем стоит заметить, то app.module.ts является точкой входа (ключевым модулем). Поэтому если мы создаем другие/новые модули под какие-то задачи, мы должны убедиться что они указаны и ипрортированы в наш ключевой модуль, от которого уже будет разростатся логика приложения. 

Далее разберемся с певыми контроллерам и провайдерами(сервисами) нашего Nest приложения. Создадим app.controller.ts и app.service.ts.

Внутри controller.ts мы используем декоратор @Controller(), ниже которого мы создаем класс к которому этот декоратор будет применен. Параметром в @Controller передаем маршрут, по которому будут отрабатывать запросы которые мы опишем в классе. Например - '/api'. И теперь этот контроллер будет отрабатывать только по маршруту '/api'. Если мы ничего в него не передаем, то он будет обрабатываться по корневому пути - '/'. А уже внутри @Controller, мы также можем воспользоваться такими декораторами как @Get, @Post и т.д.

Но @Get, @Post и т.д. не так просты. Они так же как и @Controller, принимают внутри себя параметром маршрут по которому они будут отрабатывать. Например, если у нас есть @Controller(/api), а внутри него @Get(/test), то наш контроллер теперь будет иметь GET метод, который будет отрабатывать только по маршруту '/api/test'. P.S. Пустой @Get = корневой путь - '/'.
Если внутри контроллера мы использыуем одинаковый метод запроса, с одинаковым путем, то NestJS отработает только самый первый на очереди метод. А второй метод-дубликат просто проигнорирует.

Так же в NestJS мы больше не используем "res, req" лексику. С "res, req" - NestJS разбирается автоматически под капотом, при помощи @Body(работает с json) @Param(работает с query) декоратора.

Такая логика заменяет систему роутинга, которую мы зачастую используем в　приложениях написаных на express.

Далее поговорил о провайдерах (сервисах). Они хранят в себе сервис логику и работают только в рамках того модуля куда их добавили. Чтобы использовать их внутри модуля, их нужно сперва туда импортировать. После чего мы можем использовать их где угодно в рамках текущего модуля. Но как их передать например в контроллер который находиться в том же модуле? Для этого мы воспользуемся Dependancy Injection. И просто будем передавать в конструктор контроллера те сервисы, которые мы хотим в нем использовать. Но если мы попытаемся использовать сервис который предварительно не был указан в модуле, то этот сервис работать не будет. P.S. Один сервис может использоваться в разных контроллерах
 
Пример импорта сервиса в модуль:
```
@Module ({
    imports: [], //Для случая если мы хотим импорт другие модули. Если ничего не импорт - можем не указывать 
    controllers: [AppController],
    providers: [AppServicel], 
})
```

Самый главный декоратор который используется внутри сервиса - это @Injectable(). Он как раз таки и помогает нам инжектировать созданный нами класс сервиса в другие части текущего модуля.

***HTTP request decorators***
When it comes to decorators like @Query, @Param, and @Body, they are typically used in the context of handling HTTP requests and extracting data from those requests. Let's explore the differences between these decorators:

@Query: This decorator is used to extract query parameters from an HTTP request. Query parameters are key-value pairs added to the URL after a question mark (?). For example, in the URL /users?name=John&age=25, the query parameters are name and age. You can use the @Query decorator to access these values in your NestJS controller method.

@Param: This decorator is used to extract route parameters from an HTTP request. Route parameters are dynamic parts of the URL that are defined in the route configuration. For example, in the URL /users/123, where 123 represents a user ID, you can use the @Param decorator to extract this value and use it in your controller method.

@Body: This decorator is used to extract the request body from an HTTP request. The request body contains data that is sent by the client in the HTTP request payload, typically in JSON format. You can use the @Body decorator to access and deserialize the data sent by the client.

To illustrate their usage, let's consider an example of a user controller:
```
import { Controller, Get, Post, Param, Query, Body } from '@nestjs/common';

@Controller('users')
export class UserController {
  @Get(':id')
  getUser(@Param('id') id: string) {
    // Retrieves a user with the given ID
  }

  @Get()
  getUsers(@Query('name') name: string, @Query('age') age: number) {
    // Retrieves users based on the provided query parameters
  }

  @Post()
  createUser(@Body() user: CreateUserDto) {
    // Creates a new user using the provided data in the request body
  }
}

```

# Описание разработки проекта
Основной функционал платформы будет включать в себя музыкальные альбомы, треки и коментарии пользователей. Логика креков и коментов бедет объеденена, так как выносить функционал коментов в отдельную логику нет смысла. Под альбомы сделаем БД но какую-то логику писать не будем (остается как ДЗ).

Для начала, в папке src создаем файл main.ts - это будет нашей входной точкой приложения. И создадим там базовую/стартовую конфигурацию нашего сервера, которая включает в себя app.module.ts. Это будет базовой конфигурацией нашего сервера. Под капотом main.ts работает как express приложение. И как в express, мы создаем приложение и задаем ему порт.

Создадим папки под рабочею логику приложения. В src создаем папки под два следующих модуля: album, track. А внутри уже модули, контроллеры и сервисы.

Дале установим подключение c БД. Использовать будем Монго, поэтому устанавливаем mongoose (описание установки в документации Nest.js). На сайте Mongo создаем кластер. Подключаем его в app.module.ts, путем добавления в импорты (чтобы могли использовать БД во всех дочерних модулях). Модели таблиц БД мы будем хранить в папках под каждую отдельную фитчу. Например: src/track/schemas.

Установим и настроим пакет, чтобы мы могли пользоваться .env файлом: npm i --save @nestjs/config.

Чтобы именть возможность пользоваться созданими БД моделями - импортируем их, но уже в родительский модуль самой фитчи track.module.ts. А далее при помощи Dependency Injection (@InjectModel()), будем передавать их в те сервисы, где мы будем их использовать (процесс описан в документации Nest.js). В нашем случае это будет - track.service.ts.

Когда мы хотим создать или обновить данные в БД, то мы должны передать отвечающему за это сервису, не только модель таблицы, с которой он будет работать, но и данные которые он будет в ней создавать обновлять. Для получения данных в конкретный метод сервиса, зачастую используют Data Transfer Object (Dto). Вкратце, Dto - это просто класс, который описывает те поля, которые мы ожидаем на входе в конкретную функцию.

Внутри папки "track", создаем отдельную папку "Dto", где будет указано, какие типы данных "track.service.ts" методы будут в себя принимать.

Далее применяем созданный "Dto" класс, к нужному нам методу. Пусть, например, это будет метод "create" в "track.service.ts". Выглядеть это будет следующим образом:
"async create(createTrackDto: CreateTrackDto): Promise<Track>"
"createTrackDto: CreateTrackDto" - имяПеременной: КлассКоторыйИспользуем
"Promise<Track>" - так как метод create асинхронный, то мы возвращаем промис созданой нами таблицы

Но откуда мы берем данные для "Dto"? А берем мы их из тела запроса, который нам приходит в "track.controller.ts" на @Post() запрос: create(@Body() createTrackDto: CreateTrackDto).
Если мы работаем с query, то используем: "@Get(':id_name') -> @Param('id_name') id_var: typings". id_var - это переменная которая будет хранить в себе пришедший id_name.

Таки образом прописываем все главные сервисы и контроллеры.

Отдельно хотел бы обратить внимание на такой сервис как `const getOneTrack = await this.trackModel.findById(id).populate('comments');`, а особе на применяемы в нем метод - `.populate('comments');`. Дело в том что БД таблица для каждого трека содержит в себе поле 'comments'. Это поле содержит в себе IDшники коментариев к треку, а также оно привязано к БД таблице которая хранит в себе эти самые коментарии - 'Comment'. Тем самым при желании, мы можем возвращать отдельный трек либо просто с указанимы IDшниками в поле 'comments'. Либо при помощи `.populate('comments');`, мы можем наполнить наше поле 'comments' полноценными коментариями которые находяться и всталяются туда через указанные IDшники. А все благодаря тому, что мы связали БД таблицы 'Tracks' и 'Comment'.

На данном этапе мы научились создавать базовую информацию об треках и коментах. Теперь реализуем подгрузку аудио и картинок для альбома. С базовой информацией можно ознакомиться в официальной Nest документации - вкладка File Upload. В Nest работа с файлами идет с помощью библиотеки 'multer'. В нашем случае мы будем загружать сразу несколько файлов, поэтому для этого нужно будет воспользоваться (all with different field name keys) - `FileFieldsInterceptor()`. Воспользуемся им в нашем контроллере.

После того как мы получили файлы в контроллере и передалих их в сервис, теперь нам нужно где-то эти файлы сохранить. Логику по сохранению файлов и работе с ними, мы не будем засовывать в сервис "track", так как как код нужно деструктуризировать, а не пытаться запихнуть разную логику в один сервис. Поэтому, вместо этого создадим отдельный модуль для работы с файлами - src/file/file.module.ts. И пропишем логику по работе с файлами в file.service.ts.

Прописаная в file.service.ts автоматически создаст новые папки в нашем проекте: src/static/audio и src/static/picture. Эти папки мы создали НЕ вручную, а написали для этого скрипт.

Философия по сохранению фалов следующая. Наш бек работает в рамках какой-то операционной системы. У каждой операционки своя система управления файлами (файловая система) и свои особенности управления путями директорий. Бек получает какие-то файлы, которые нужно сохранить, удалить или обновить. NodeJS сам определяет на какой операционке работает бек. После, мы даем NodeJS универсалиные команды, по например, сохранению файла в какой-то директории. NodeJS подстраивается под текущею операционку/ее пути и выполняет данные нами команды по работе с файлами.

Для каждого файла мы будем генерить уникальное имя, поэтому установим `npm i uuid`

Теперь, чтобы использовать новый сервис file.service.ts внутри track.service.ts, нам нужно связать их вместе и после чего инжектировать его туда. Так как на данный момент file.service.ts изолирован в своем собственном FileModule модуле, то сперва нам нужно экспортировать/зарегестрировать FileModule в самом корневом модуле - app.module.ts. Дело в том, что так как app.module.ts - это общий родительль как TrackModule так и FileModule, сперва мы должны зерегестрировать FileModule там. После чего, мы сможем использовать его во всех остальных дочерних модулях, что пренадлежат родителю, включая TrackModule. Теперь мы можем добавить сервис file.service.ts внутрь TrackModule, что даст нам возможность также и использовать его уже и в - track.service.ts.

P.S. На примере выше мы увидели, что мы также можем создавать модули лишь с одним сервисом, который мы потом можем уже использовать в других модулях. Модуль не обязан включать одновременно и контроллеры и сервисы.

Далее, чтобы нам было удобно быстро и легко находить нужные нам файлы - обновим track.service.ts. При сохранении инфы о треке в БД, добавим также поля где будут указаны пути для картинки и трека в виде строки. Например - image/unique_name.jpg.

Теперь разберемся как по запросу от клиента, получать сохраненные ранее файлы. Для этого нужно научить наш серевер раздавать статику. В официально дакументации для NestJS лдя этого есть раздел - Serve Static. В нем указан пакет который мы должны скачать, чтобы раздавать статику на клиент - `npm install --save @nestjs/serve-static`. И чтобы его использовать, добавим в импорты родительского модуля app.module.ts, следующий импорт - ServeStaticModule. При помощи ServeStaticModule указываем где у нас хранятся статические файлы (папка 'static'). Теперь сервер может раздавать файлы которые находятся внутри папки 'static'.

Теперь когда мы добавили необходимый импорт и задали ему путь - мы можем отображать файлы указав их путь в поисковой строке браузера клиента. Например - http://localhost:3000/image/unique_name.jpg или http://localhost:3000/audio/unique_name.mp3. Напомню, что путь "image/unique_name.jpg" мы генерируем и сохраняем в БД при создании файла.

Продолжим заниматься функционалом бека. Осталось допилить несколько фитч. Займемся функцией которая будет увиличивать количество прослушиваний трека и сохранять эту инфу в БД. После того как трек оканчивает играть на клиентской стороне, клиет отправляет запрос на @Post('/listen/:id') addListened(), для увилечения количества прослушиваний.

Текущая функция getAll() в контроллере для треков, по запросу отправляет клиенту все имеющиеся треки. Но так как треков может быть тысячи, то лучше продумать систему пагинации и отправлять их клиенту частями, а не все разом. Поэтому подправим getAll() и соответствующий этой функции сервис. getAll() будет принимать 2 параметра - 'count' количество треков которые мы должны вернуть и 'offset' отступ (сколько нужно пропустить прошлых треков, которые были уже пролистаны на прошлых страницах). И зададим дефолтные параметры count = 10, offset = 0.

И финальная фитча, без которой платформа была бы не полноценной - это поиск треков по их названию. За данный функционал будет отвечать функция searchTrack() в контроллере. P.S. Функция searchTrack работает только если поместить ее под getAll. Если поместить ее хоть немного ниже, то сервер будет выдавать ошибку! Почему так - еще не разобрался.

И самая последняя вишенка на торте - это добавить CORS, чтобы отправлять запросы с браузера. Добавим его мы в файл main.ts.

Все, на этом с бекендом мы завершили!